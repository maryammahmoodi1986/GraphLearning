---
title: "۴-۴: انتقال کد از MATLAB به پایتون و تغییرات اعمال شده"
---

[قبلی](section4-3.qmd) 

انتقال کد از MATLAB به پایتون یکی از مهم‌ترین مراحل این پروژه بوده است که نه تنها به دلیل محدودیت‌های تکنولوژیکی، بلکه برای بهره‌گیری از امکانات پیشرفته‌تر و دسترسی آزاد انجام شد. این انتقال فرصتی برای بازنگری و بهبود الگوریتم‌های موجود فراهم کرد.

## دلایل انتقال به پایتون

 ۱.دسترسی‌پذیری و رایگان بودن

پایتون یک زبان متن‌باز و رایگان است، در حالی که MATLAB نیازمند لایسنس تجاری است که برای بسیاری از پژوهشگران محدودیت ایجاد می‌کند. این ویژگی امکان استفاده گسترده‌تر از ابزارهای توسعه‌یافته را فراهم می‌کند.

 ۲. کتابخانه‌های غنی برای محاسبات عددی

پایتون کتابخانه‌های قدرتمندی مانند NumPy، SciPy، و Pandas برای محاسبات عددی و ریاضی ارائه می‌دهند که جایگزین مناسبی برای ابزارهای داخلی MATLAB محسوب می‌شوند.

 ۳. خوانایی و انعطاف‌پذیری

پایتون امکان استفاده از ساختارهای شیءگرا و ابزارهای مدرن را فراهم می‌کند که کد را خواناتر و ماژولارتر می‌کند. این ویژگی‌ها نگهداری و توسعه کد را آسان‌تر می‌سازند.

 ۴. جامعه بزرگ و پشتیبانی گسترده

جامعه بزرگ پایتون امکان استفاده از ابزارهای جدید و به‌روزرسانی‌های مداوم را فراهم می‌کند. این امکان باعث می‌شود که پروژه با آخرین پیشرفت‌های تکنولوژیکی همگام باشد.

## چالش‌های انتقال

 ۱. تفاوت در ساختار داده‌ها

MATLAB به‌طور پیش‌فرض از ماتریس‌ها استفاده می‌کند، در حالی که پایتون از آرایه‌های NumPy و لیست‌ها بهره می‌برد. این تفاوت نیاز به بازنویسی عملیات ماتریسی داشت و تطبیق ساختار داده‌ها را الزامی کرد.

 ۲. مدیریت حافظه

MATLAB مدیریت حافظه را به‌صورت خودکار انجام می‌دهد، اما در پایتون نیاز به ابزارهای بهینه‌سازی حافظه بود. این امر مستلزم طراحی دقیق‌تر الگوریتم‌ها و مدیریت بهتر منابع شد.

 ۳. عملکرد محاسباتی

برخی عملیات در MATLAB به‌دلیل بهینه‌سازی‌های داخلی سریع‌تر هستند، بنابراین باید از ابزارهای مناسب پایتون برای حفظ عملکرد استفاده می‌شد. این چالش مستلزم انتخاب دقیق کتابخانه‌ها و تکنیک‌های بهینه‌سازی بود.

 ۴. عدم وجود توابع BNT

توابع کمکی مانند `score_dags`، `mk_all_dags` و `mcmc_sample_to_hist` در پایتون موجود نبودند و نیاز به پیاده‌سازی از ابتدا داشتند. این امر زمان قابل‌توجهی را برای توسعه و آزمایش نیاز داشت.

## تغییرات و بهبودهای اعمال شده

 ۱. ساختار شیءگرا و ماژولار

در MATLAB، کد به‌صورت یک تابع اصلی (`learn_struct_mcmc`) با توابع کمکی جداگانه نوشته شده بود. در پایتون، دو کلاس `MCMCStructureLearner` و `GibbsStructureLearner` تعریف شدند.

**مزایای این تغییر:**
- بهبود خوانایی کد و سازماندهی بهتر
- امکان استفاده مجدد از کدها
- مدیریت ساده‌تر متغیرها و حالت‌ها
- قابلیت گسترش و نگهداری آسان‌تر

 ۲. استفاده از NumPy و SciPy

عملیات ماتریسی MATLAB با استفاده از NumPy بازنویسی شدند تا عملکرد مشابهی با سرعت بالا حفظ شود. برای محاسبات ریاضی مانند تابع گاما لگاریتم (مورد نیاز در امتیازدهی بیزی)، از SciPy استفاده شد.

**مزایای این انتخاب:**
- جایگزین مناسب برای ابزارهای داخلی MATLAB
- محاسبات سریع و دقیق
- پایداری عددی بهتر

 ۳. بهبود تابع امتیازدهی

در MATLAB، تابع `score_dags` برای محاسبه امتیاز BDeu یا BIC استفاده می‌شد. در پایتون، دو تابع امتیازدهی جداگانه برای Bayesian Score (BDeu) و BIC پیاده‌سازی شدند، با پیش‌فرض BDeu.

امکان تنظیم پارامتر alpha (پارامتر توزیع پیشین) اضافه شد که برای داده‌های کوچک‌تر و متغیرهای با احتمال پایین (مانند Asia در شبکه Asia) مناسب‌تر است و دقت را بهبود داده است.

 ۴. افزودن Simulated Annealing به MCMC

در MATLAB، الگوریتم Metropolis-Hastings به‌صورت استاندارد بود. در پایتون، یک برنامه خنک‌سازی با Simulated Annealing اضافه شد.

**مزایای این بهبود:**
- افزایش کاوش در مراحل اولیه
- همگرایی بهتر به گراف‌های بهینه‌تر
- بهبود دقت و پایداری نتایج

 ۵. بهینه‌سازی محاسباتی با کش کردن

محاسبات امتیازدهی که در MATLAB به‌صورت تکراری انجام می‌شدند، در پایتون با استفاده از تکنیک کش کردن بهینه شدند.

**نتایج حاصل:**
- کاهش زمان اجرای الگوریتم‌ها
- کاهش محاسبات تکراری
- بهبود کارایی کلی سیستم

 ۶. اعمال محدودیت حداکثر والدین

در MATLAB، محدودیتی برای تعداد والدین گره‌ها وجود نداشت که می‌توانست به گراف‌های بیش از حد پیچیده منجر شود. در پایتون، پارامتر `max_parents` (پیش‌فرض ۴) اضافه شد.

**نتایج این محدودیت:**
- Precision را به‌ویژه در Gibbs به ۱.۰۰۰ رساند
- جلوگیری از over-fitting
- بهبود تفسیرپذیری مدل

 ۷. مقداردهی اولیه با دانش پیشین

در MATLAB، گراف اولیه معمولاً خالی یا تصادفی بود. در پایتون، گراف اولیه با لبه‌های شناخته شده شبکه (مانند Asia → Tuberculosis) مقداردهی شد.

**مزایای این تغییر:**
- هدایت کاوش به سمت ساختارهای محتمل‌تر
- بهبود Precision و Recall
- کاهش زمان همگرایی

 ۸. افزایش تعداد نمونه‌ها و داده‌ها

تعداد نمونه‌های MCMC و Gibbs از ۱۰۰ به ۵۰۰۰ و burn-in از ۱۰ به ۲۰۰۰ افزایش یافت. همچنین، تعداد نمونه‌های داده از ۱۰۰۰ به ۵۰۰۰ افزایش یافت.

**نتایج این افزایش:**
- بهبود همگرایی
- شناسایی دقیق‌تر روابط
- کاهش تأثیر نویز و نوسانات تصادفی

 ۹. بهبود گراف اجماعی در Gibbs

در MATLAB، گراف نهایی از میانگین ساده گراف‌ها به دست می‌آمد. در پایتون، گراف اجماعی با آستانه ۰.۷ ساخته شد.

**نتایج این تغییر:**
- Precision را به ۱.۰۰۰ رساند
- حذف لبه‌های با احتمال پایین
- اما برخی لبه‌های درست را نیز حذف کرد

 ۱۰. افزودن تحلیل‌های جامع‌تر

توابع برای مقایسه لبه به لبه و نمایش احتمالات لبه‌ها اضافه شدند تا خطاها دقیق‌تر شناسایی شوند.

**مزایای این بهبود:**
- درک بهتر نقاط ضعف
- شناسایی دقیق‌تر لبه‌های از دست رفته
- امکان تحلیل عمیق‌تر نتایج

 ۱۱. مدیریت خطاها و پایداری عددی

در MATLAB، سرریز یا زیرریز عددی ممکن بود رخ دهد. در پایتون، با نرمال‌سازی امتیازها و محدود کردن مقادیر بزرگ، این مشکلات برطرف شدند.

**مزایای این بهبود:**
- پایداری عددی بهتر
- جلوگیری از خطاهای محاسباتی
- نتایج قابل اعتمادتر

 ۱۲. افزودن Gibbs Sampling

نسخه MATLAB فقط از MCMC استفاده می‌کرد. در پایتون، Gibbs Sampling برای بهبود دقت پیاده‌سازی شد.

**مزایای این افزودن:**
- Precision بالاتری (۱.۰۰۰) ارائه داد
- امکان مقایسه دو روش
- انعطاف‌پذیری بیشتر در انتخاب روش

 ۱۳. تولید داده‌های استاندارد

در MATLAB، داده‌های شبکه Asia به‌صورت جداگانه تولید می‌شدند. در پایتون، یک تابع اختصاصی برای تولید داده‌های قابل تکرار شبکه Asia پیاده‌سازی شد.

**مزیت این تغییر:**
- امکان آزمایش‌های منسجم و قابل تکرار
- استانداردسازی فرآیند تولید داده

## مقایسه عملکرد

### نسخه MATLAB

**نقاط ضعف:**
- Precision و Recall پایین‌تر به‌دلیل تعداد نمونه‌های کم
- عدم استفاده از دانش پیشین
- زمان اجرا برای شبکه‌های کوچک سریع‌تر، اما برای شبکه‌های بزرگ کند
- انعطاف‌پذیری محدود به توابع BNT

### نسخه پایتون

**نقاط قوت:**
- **Precision:** ۱.۰۰۰ برای Gibbs و ۰.۶۶۷ برای MCMC
- **Recall:** ۰.۵۰۰ برای هر دو روش
- **SHD:** ۴ برای Gibbs و ۶ برای MCMC
- **زمان اجرا:** Gibbs (۲۱۲.۶ ثانیه) کندتر، اما MCMC (۲۷.۰ ثانیه) سریع
- **انعطاف‌پذیری:** قابلیت تنظیم پارامترها و افزودن Gibbs Sampling

## مشکلات باقی‌مانده

 ۱. نرخ پذیرش پایین در MCMC

نرخ پذیرش پایین (۰.۰۰۴) در MCMC نشان‌دهنده کاوش ناکافی است که نیاز به تنظیم بهتر پارامترهای Simulated Annealing دارد.

 ۲. لبه‌های از دست رفته

لبه‌هایی مانند Tuberculosis → Asia، LungCancer → Smoking و Xray → Either شناسایی نشدند که نشان‌دهنده نیاز به تنظیم آستانه یا بهبود الگوریتم است.

 ۳. زمان اجرای Gibbs

زمان اجرای ۲۱۲.۶ ثانیه برای Gibbs نسبتاً بالاست و نیاز به بهینه‌سازی بیشتر دارد.

## پیشنهادات برای بهبود

 ۱. بهبود نرخ پذیرش MCMC

تنظیم دقیق‌تر برنامه خنک‌سازی برای کاوش بهتر و افزایش نرخ پذیرش.

 ۲. افزایش داده‌ها

افزایش تعداد نمونه‌های داده به ۱۰۰۰۰ برای بهبود کیفیت یادگیری.

 ۳. موازی‌سازی

استفاده از ابزارهای موازی‌سازی برای کاهش زمان Gibbs و بهبود کارایی کلی.

 ۴. کاهش آستانه گراف اجماعی

کاهش آستانه به ۰.۵ برای شناسایی لبه‌های بیشتر در Gibbs.

 ۵. تحلیل همگرایی

رسم نمودارهای نرخ پذیرش و تعداد لبه‌ها برای بررسی همگرایی و تشخیص مشکلات.

## نتیجه‌گیری

انتقال از MATLAB به پایتون نه تنها مشکلات دسترسی و هزینه را حل کرد، بلکه فرصتی برای بهبود قابل‌توجه الگوریتم‌ها فراهم آورد. بهبودهایی مانند ساختار شیءگرا، بهینه‌سازی محاسباتی، Simulated Annealing، و استفاده از دانش پیشین، دقت و انعطاف‌پذیری را افزایش داد.

الگوریتم Metropolis-Hastings در MATLAB برای یادگیری ساختار شبکه‌های بیزی مناسب بود، اما محدودیت‌هایی مانند نرخ پذیرش پایین داشت. Gibbs Sampling در پایتون اضافه شد و Precision بالاتری (۱.۰۰۰) ارائه داد.

نسخه پایتونی عملکرد بهتری نسبت به MATLAB دارد، اما برای رفع مشکلات باقی‌مانده مانند لبه‌های از دست رفته و زمان اجرای Gibbs، نیاز به بهبودهای بیشتری است. این پروژه نشان می‌دهد که انتقال تکنولوژی می‌تواند فرصتی برای نوآوری و بهبود باشد، نه فقط یک تغییر ساده پلتفرم.

[قبلی](section4-3.qmd) 
