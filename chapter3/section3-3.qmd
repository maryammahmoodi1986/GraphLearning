---
title: "۳-۳: الگوریتم‌های تکاملی در بهینه‌سازی گراف‌های جهت‌دار و بی‌جهت"
---
[قبلی](section3-2.qmd) 


الگوریتم‌های تکاملی ابزارهای قدرتمندی برای حل مسائل پیچیده بهینه‌سازی هستند، به‌خصوص در حوزه گراف‌ها که برای مدل‌سازی روابط در شبکه‌های اجتماعی، سیستم‌های حمل‌ونقل، و داده‌های بزرگ استفاده می‌شوند. این آموزش با تمرکز بر کدهای ارائه شده در سند، به توضیح چگونگی کارکرد کلونی زنبور مصنوعی (ABC)، جستجوی کلونی مورچگان (ACO)، الگوریتم‌های ژنتیک (GA)، جستجوی هارمونی (HS)، و الگوریتم رقابت استعماری (ICA) می‌پردازد.

محور اصلی این آموزش، الگوریتم ژنتیک است، اما سایر الگوریتم‌ها نیز به‌طور خلاصه بررسی می‌شوند تا دید جامعی از مقایسه آن‌ها ارائه شود.

در این بخش، ابتدا اصول الگوریتم‌های تکاملی را تشریح می‌دهیم، سپس به چگونگی ساخت گراف از داده‌های خام، تفاوت گراف‌های جهت‌دار و بی‌جهت، و روش‌های ارزیابی عملکرد الگوریتم‌ها می‌پردازیم.

## اصول الگوریتم‌های تکاملی

الگوریتم‌های تکاملی از فرآیندهای طبیعی مانند تکامل بیولوژیکی، رفتار حشرات، یا رقابت‌های اجتماعی الهام گرفته‌اند. این الگوریتم‌ها برای مسائل بهینه‌سازی با فضای جستجوی بزرگ مناسب‌اند، زیرا نیازی به محاسبات گرادیان یا مشتق ندارند و می‌توانند جواب‌های نزدیک به بهینه را پیدا کنند.

### ۱. الگوریتم ژنتیک (GA)

الگوریتم ژنتیک که در دهه ۱۹۷۰ توسط جان هالند معرفی شد، از اصول تکامل داروین الهام گرفته است. این الگوریتم بر پایه جمعیتی از «افراد (Individuals)» کار می‌کند که هر فرد یک راه‌حل احتمالی برای مسئله است. در مسائل گراف، هر فرد معمولاً به‌صورت لیستی از یال‌ها (Edges) یا گره‌ها نشان داده می‌شود.

#### مراحل کار الگوریتم ژنتیک:

**۱. ایجاد جمعیت اولیه:** در ابتدا، مجموعه‌ای از افراد به‌صورت تصادفی تولید می‌شوند. برای مثال، در یک گراف، هر فرد می‌تواند زیرمجموعه‌ای از یال‌های گراف باشد که به‌طور تصادفی انتخاب شده‌اند.

**۲. ارزیابی برازش (Fitness):** هر فرد بر اساس تابع برازش ارزیابی می‌شود. تابع برازش کیفیت راه‌حل را نشان می‌دهد. در مسائل گراف، برازش ممکن است تعداد گره‌های پوشش داده‌شده توسط یال‌های انتخابی یا نسبت گره‌های منحصربه‌فرد به تعداد یال‌ها باشد.

**۳. انتخاب والدین:** افراد با برازش بالاتر شانس بیشتری برای انتخاب به‌عنوان والدین دارند. روش‌های انتخاب شامل انتخاب چرخ رولت (بر اساس احتمال متناسب با برازش) یا انتخاب تورنمنت (انتخاب بهترین از یک زیرمجموعه تصادفی) است.

**۴. تقاطع (Crossover):** دو والد انتخاب شده ترکیب می‌شوند تا فرزندان جدیدی تولید کنند. مثلاً، یک نقطه تقاطع تصادفی در لیست یال‌ها انتخاب می‌شود و بخش‌هایی از دو والد جابه‌جا می‌شوند.

**۵. جهش (Mutation):** برای جلوگیری از گیر کردن در جواب‌های محلی و حفظ تنوع، تغییرات تصادفی در فرزندان اعمال می‌شود، مثلاً جایگزینی یک یال با یال دیگر از مجموعه کل یال‌ها.

**۶. جایگزینی:** جمعیت جدید جایگزین جمعیت قدیمی می‌شود و این فرآیند تا تعداد مشخصی نسل تکرار می‌شود.

در مسائل گراف، الگوریتم ژنتیک می‌تواند برای یافتن زیرگراف‌های ماکزیمال، پوشش گره‌ها، یا مسیرهای بهینه استفاده شود.

### ۲. الگوریتم کلونی مورچگان (ACO)

الگوریتم کلونی مورچگان، که توسط مارکو دوریگو در دهه ۱۹۹۰ معرفی شد، از رفتار مورچه‌ها در یافتن کوتاه‌ترین مسیر به غذا الهام گرفته است. مورچه‌ها با ترشح فرومون، مسیرهای خوب را علامت‌گذاری می‌کنند.

#### مراحل کار ACO:

**۱. ساخت جواب:** هر مورچه یک راه‌حل (مثلاً لیستی از یال‌ها) را با توجه به سطح فرومون روی یال‌ها انتخاب می‌کند. یال‌هایی با فرومون بیشتر، احتمال انتخاب بالاتری دارند.

**۲. به‌روزرسانی فرومون:** فرومون‌ها به‌مرور تبخیر می‌شوند تا مسیرهای ضعیف فراموش شوند. همچنین، بر اساس کیفیت راه‌حل‌ها، فرومون روی مسیرهای خوب افزایش می‌یابد.

**۳. تکرار:** فرآیند تا تعداد مشخصی نسل یا تا یافتن جواب بهینه ادامه می‌یابد.

ACO برای مسائل مسیر کوتاه یا پوشش گراف مناسب است و در گراف‌های جهت‌دار و بی‌جهت کاربرد دارد.

### ۳. الگوریتم کلونی زنبور مصنوعی (ABC)

الگوریتم ABC از رفتار زنبورهای عسل الهام گرفته و شامل سه نوع زنبور است: کارگر، ناظر، و پیشاهنگ.

#### مراحل کار ABC:

**۱. زنبورهای کارگر:** هر زنبور کارگر یک منبع غذایی (راه‌حل) را بهبود می‌دهد، مثلاً با تغییر یک یال در لیست.

**۲. زنبورهای ناظر:** این زنبورها بر اساس برازش، منابع بهتری انتخاب می‌کنند و آن‌ها را بهبود می‌دهند.

**۳. زنبورهای پیشاهنگ:** منابع ضعیف را رها کرده و راه‌حل‌های جدیدی به‌صورت تصادفی تولید می‌کنند.

### ۴. جستجوی هارمونی (HS)

الگوریتم جستجوی هارمونی از فرآیند خلق موسیقی الهام گرفته و هر راه‌حل به‌عنوان یک هارمونی در نظر گرفته می‌شود.

#### مراحل کار HS:

**۱. حافظه هارمونی:** مجموعه‌ای از هارمونی‌های خوب (راه‌حل‌ها) ذخیره می‌شود.

**۲. ساخت هارمونی جدید:** با احتمال تنظیم (PAR) تغییر می‌کند. در غیر این‌صورت، هارمونی جدیدی به‌صورت تصادفی ساخته می‌شود.

**۳. جایگزینی:** اگر هارمونی جدید بهتر باشد، جایگزین ضعیف‌ترین هارمونی در حافظه می‌شود.

### ۵. الگوریتم رقابت استعماری (ICA)

ICA از رقابت بین امپراتوری‌ها الهام گرفته و شامل امپریالیست‌ها (بهترین راه‌حل‌ها) و مستعمرات (راه‌حل‌های وابسته) است.

#### مراحل کار ICA:

**۱. جذب مستعمرات:** مستعمرات به‌سمت امپریالیست حرکت می‌کنند و بهبود می‌یابند.

**۲. رقابت:** امپراتوری‌های ضعیف مستعمرات خود را از دست می‌دهند و امپراتوری‌های قوی‌تر آن‌ها را جذب می‌کنند.

## ساخت گراف از داده‌ها

ساخت گراف از داده‌های خام اولین گام در فرآیند بهینه‌سازی است. در سند ارائه شده، داده‌ها از یک فایل متنی به نام `Amazon0302.txt` بارگذاری می‌شوند که شامل یال‌های یک گراف واقعی (مانند شبکه خرید آمازون) است. هر خط از فایل شامل دو عدد است که گره‌های مبدا و مقصد یک یال را نشان می‌دهند.

### چگونگی ساخت گراف:

**۱. بارگذاری داده‌ها:** داده‌ها از فایل خوانده شده و به‌صورت لیست تاپل‌های (u,v) ذخیره می‌شوند. برای کاهش بار محاسباتی، تنها ۱۰۰۰ یال اول نمونه‌برداری می‌شوند.

**۲. ساختار گراف:** گراف به‌صورت لیست یال‌ها ذخیره می‌شود، نه به‌صورت ساختار پیچیده مانند کتابخانه NetworkX، زیرا هدف بهینه‌سازی زیرمجموعه‌ای از یال‌هاست، نه تحلیل ساختاری گراف.

این روش ساده امکان پردازش سریع و اجرای الگوریتم‌های تکاملی را فراهم می‌کند.

## تمایز گراف‌های جهت‌دار و بی‌جهت

گراف‌های جهت‌دار و بی‌جهت تفاوت‌های اساسی در ساختار و کاربرد دارند:

### ۱. گراف جهت‌دار (Directed Graph)

در این نوع گراف، یال‌ها جهت دارند (از گره u به v). این جهت‌دار بودن نشان‌دهنده رابطه‌ای یک‌طرفه است، مانند لینک‌های وب یا جریان داده. در سند، یال‌ها مستقیماً از داده‌های خام استفاده می‌شوند و تابع برازش تعداد گره‌های منحصربه‌فرد پوشش داده‌شده توسط یال‌ها را نسبت به تعداد کل یال‌ها محاسبه می‌کند.

### ۲. گراف بی‌جهت (Undirected Graph)

در این گراف، یال‌ها دوطرفه هستند و جهت اهمیت ندارد (یال (u,v) همان (v,u) است). برای تبدیل به گراف بی‌جهت، یال‌ها مرتب شده و تکرارها حذف می‌شوند. تابع برازش مشابه است اما یال‌ها را به‌صورت دوطرفه در نظر می‌گیرد، که باعث کاهش تعداد یال‌های مؤثر می‌شود.

این تمایز در تابع برازش تأثیر می‌گذارد، زیرا در گراف جهت‌دار ممکن است گره‌های بیشتری پوشش داده شوند، اما در بی‌جهت، یال‌های تکراری حذف می‌شوند و پوشش کمتری ایجاد می‌شود.

## ارزیابی عملکرد الگوریتم‌ها

ارزیابی عملکرد الگوریتم‌ها بخش کلیدی این مطالعه است و شامل چندین معیار است:

### ۱. تابع برازش (Fitness Function)

تابع برازش معیاری برای سنجش کیفیت راه‌حل است. در اینجا، نسبت تعداد گره‌های منحصربه‌فرد به تعداد یال‌های انتخاب شده استفاده می‌شود. این معیار نشان‌دهنده کارایی پوشش گراف است. برای گراف‌های جهت‌دار، جهت یال‌ها حفظ می‌شود، اما در گراف‌های بی‌جهت، یال‌ها به‌صورت متقارن پردازش می‌شوند.

### ۲. تاریخچه نسل‌ها

هر الگوریتم در تعداد مشخصی نسل (در اینجا ۱۰ نسل) اجرا می‌شود و بهترین برازش در هر نسل ثبت می‌شود. این تاریخچه نشان می‌دهد که الگوریتم‌ها چگونه با گذشت زمان بهبود می‌یابند.

### ۳. مقایسه چندگانه

برای اطمینان از پایداری نتایج، هر الگوریتم ۳۰ بار اجرا می‌شود. معیارهای زیر محاسبه می‌شوند:
- میانگین برازش: میانگین بهترین برازش در نسل آخر
- انحراف معیار برازش: نشان‌دهنده پایداری یا تغییرات عملکرد بین اجراها
- زمان اجرا: میانگین زمان موردنیاز برای اجرای هر الگوریتم

### ۴. رسم نمودارها

نمودارهای خطی و میله‌ای برای مقایسه برازش، زمان اجرا، و انحراف معیار رسم می‌شوند. این نمودارها تفاوت عملکرد الگوریتم‌ها را در گراف‌های جهت‌دار و بی‌جهت نشان می‌دهند.

### ۵. تحلیل مقیاس‌پذیری

برای بررسی رفتار الگوریتم‌ها در گراف‌های بزرگ‌تر، سایزهای مختلف گراف (از ۱۰ تا ۱۰۰۰ گره) آزمایش می‌شوند. زمان اجرا و کیفیت جواب با افزایش اندازه گراف تحلیل می‌شود.

## نتایج کلیدی

### نتایج عملکرد

- در گراف‌های جهت‌دار، الگوریتم‌های ABC و HS بهترین برازش (حدود ۱.۷) را دارند، در حالی که GA و ACO عملکرد ضعیف نشان می‌دهند.
- در گراف‌های بی‌جهت، اکثر الگوریتم‌ها (ACO، ABC، HS، ICA) برازش کامل (۱.۰) دارند، اما GA ضعیف‌تر است (حدود ۰.۷).
- از نظر زمان اجرا، HS سریع‌ترین و ACO کندترین است.

## چالش‌ها و محدودیت‌ها

### ۱. همگرایی زودرس
در GA، ممکن است الگوریتم به جواب‌های محلی گیر کند. افزایش نرخ جهش یا تنوع جمعیت می‌تواند کمک کند.

### ۲. پیچیدگی محاسباتی ACO
به‌دلیل محاسبات فرومون، زمان اجرای بالایی دارد، به‌خصوص در گراف‌های بزرگ.

### ۳. پایداری ICA
انحراف معیار بالایی دارد، که نشان‌دهنده تغییرات زیاد در عملکرد است.

### ۴. داده‌های بزرگ
در گراف‌های بزرگ، نمونه‌برداری تصادفی (مانند ۱۰۰۰ یال) ممکن است اطلاعات مهمی را حذف کند.

## نتیجه‌گیری

در گراف‌های جهت‌دار، پوشش گره‌ها بیشتر است زیرا جهت‌ها امکان اتصالات بیشتری فراهم می‌کنند. در گراف‌های بی‌جهت، حذف یال‌های تکراری باعث کاهش پوشش می‌شود. انتخاب الگوریتم مناسب بستگی به نوع مسئله، اندازه گراف، و محدودیت‌های زمانی دارد.

[قبلی](section3-2.qmd) 
